//! Metadata for items in the `crate::gpu` module

use super::*;

pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_VERBOSE_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_VERBOSE_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_VERBOSE_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_VERBOSE_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING",
    short_name: "GPU_DEVICE_CREATE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_FEATURE_CLIP_DISTANCE_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_FEATURE_CLIP_DISTANCE_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_FEATURE_CLIP_DISTANCE_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_FEATURE_CLIP_DISTANCE_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_FEATURE_DEPTH_CLAMPING_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_FEATURE_DEPTH_CLAMPING_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_FEATURE_DEPTH_CLAMPING_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_FEATURE_DEPTH_CLAMPING_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_FEATURE_INDIRECT_DRAW_FIRST_INSTANCE_BOOLEAN:
    Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_FEATURE_INDIRECT_DRAW_FIRST_INSTANCE_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_FEATURE_INDIRECT_DRAW_FIRST_INSTANCE_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_FEATURE_INDIRECT_DRAW_FIRST_INSTANCE_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_FEATURE_ANISOTROPY_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_FEATURE_ANISOTROPY_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_FEATURE_ANISOTROPY_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_FEATURE_ANISOTROPY_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_D3D12_ALLOW_FEWER_RESOURCE_SLOTS_BOOLEAN: Property =
    Property {
        module: "gpu",
        name: "SDL_PROP_GPU_DEVICE_CREATE_D3D12_ALLOW_FEWER_RESOURCE_SLOTS_BOOLEAN",
        short_name: "GPU_DEVICE_CREATE_D3D12_ALLOW_FEWER_RESOURCE_SLOTS_BOOLEAN",
        value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_D3D12_ALLOW_FEWER_RESOURCE_SLOTS_BOOLEAN,
        ty: PropertyType::BOOLEAN,
        doc: None,
        available_since: None,
    };
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING",
    short_name: "GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_VULKAN_REQUIRE_HARDWARE_ACCELERATION_BOOLEAN:
    Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_VULKAN_REQUIRE_HARDWARE_ACCELERATION_BOOLEAN",
    short_name: "GPU_DEVICE_CREATE_VULKAN_REQUIRE_HARDWARE_ACCELERATION_BOOLEAN",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_VULKAN_REQUIRE_HARDWARE_ACCELERATION_BOOLEAN,
    ty: PropertyType::BOOLEAN,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_CREATE_VULKAN_OPTIONS_POINTER: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_CREATE_VULKAN_OPTIONS_POINTER",
    short_name: "GPU_DEVICE_CREATE_VULKAN_OPTIONS_POINTER",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_CREATE_VULKAN_OPTIONS_POINTER,
    ty: PropertyType::POINTER,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_NAME_STRING",
    short_name: "GPU_DEVICE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_DRIVER_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_DRIVER_NAME_STRING",
    short_name: "GPU_DEVICE_DRIVER_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_DRIVER_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING",
    short_name: "GPU_DEVICE_DRIVER_VERSION_STRING",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_DRIVER_VERSION_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING",
    short_name: "GPU_DEVICE_DRIVER_INFO_STRING",
    value: crate::gpu::SDL_PROP_GPU_DEVICE_DRIVER_INFO_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING",
    short_name: "GPU_COMPUTEPIPELINE_CREATE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING",
    short_name: "GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING",
    short_name: "GPU_SAMPLER_CREATE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_SHADER_CREATE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_SHADER_CREATE_NAME_STRING",
    short_name: "GPU_SHADER_CREATE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_SHADER_CREATE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT",
    short_name: "GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT",
    value: crate::gpu::SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT,
    ty: PropertyType::FLOAT,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT",
    short_name: "GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT",
    value: crate::gpu::SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT,
    ty: PropertyType::FLOAT,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT",
    short_name: "GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT",
    value: crate::gpu::SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT,
    ty: PropertyType::FLOAT,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT",
    short_name: "GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT",
    value: crate::gpu::SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT,
    ty: PropertyType::FLOAT,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT",
    short_name: "GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT",
    value: crate::gpu::SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT,
    ty: PropertyType::FLOAT,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_NUMBER: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_NUMBER",
    short_name: "GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_NUMBER",
    value: crate::gpu::SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_NUMBER,
    ty: PropertyType::NUMBER,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING",
    short_name: "GPU_TEXTURE_CREATE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING",
    short_name: "GPU_BUFFER_CREATE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING: Property = Property {
    module: "gpu",
    name: "SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING",
    short_name: "GPU_TRANSFERBUFFER_CREATE_NAME_STRING",
    value: crate::gpu::SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING,
    ty: PropertyType::STRING,
    doc: None,
    available_since: None,
};
pub const METADATA_SDL_GPUPrimitiveType: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUPrimitiveType",
    short_name: "GPUPrimitiveType",
    doc: Some(
        "Specifies the primitive topology of a graphics pipeline.\n\nIf you are using POINTLIST you must include a point size output in the\nvertex shader.\n\n- For HLSL compiling to SPIRV you must decorate a float output with\n\\[\\[vk::builtin(\"PointSize\")\\]\\].\n- For GLSL you must set the gl_PointSize builtin.\n- For MSL you must include a float output with the \\[\\[point_size\\]\\]\ndecorator.\n\nNote that sized point topology is totally unsupported on D3D12. Any size\nother than 1 will be ignored. In general, you should avoid using point\ntopology for both compatibility and performance reasons. You WILL regret\nusing it.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_PRIMITIVETYPE_TRIANGLELIST",
            short_name: "TRIANGLELIST",
            doc: Some("A series of separate triangles.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_PRIMITIVETYPE_TRIANGLESTRIP",
            short_name: "TRIANGLESTRIP",
            doc: Some("A series of connected triangles.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_PRIMITIVETYPE_LINELIST",
            short_name: "LINELIST",
            doc: Some("A series of separate lines.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_PRIMITIVETYPE_LINESTRIP",
            short_name: "LINESTRIP",
            doc: Some("A series of connected lines.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_PRIMITIVETYPE_POINTLIST",
            short_name: "POINTLIST",
            doc: Some("A series of separate points.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPULoadOp: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPULoadOp",
    short_name: "GPULoadOp",
    doc: Some(
        "Specifies how the contents of a texture attached to a render pass are\ntreated at the beginning of the render pass.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BeginGPURenderPass`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_LOADOP_LOAD",
            short_name: "LOAD",
            doc: Some("The previous contents of the texture will be preserved.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_LOADOP_CLEAR",
            short_name: "CLEAR",
            doc: Some("The contents of the texture will be cleared to a color.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_LOADOP_DONT_CARE",
            short_name: "DONT_CARE",
            doc: Some(
                "The previous contents of the texture need not be preserved. The contents will be undefined.\n",
            ),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUStoreOp: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUStoreOp",
    short_name: "GPUStoreOp",
    doc: Some(
        "Specifies how the contents of a texture attached to a render pass are\ntreated at the end of the render pass.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BeginGPURenderPass`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_STOREOP_STORE",
            short_name: "STORE",
            doc: Some("The contents generated during the render pass will be written to memory.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STOREOP_DONT_CARE",
            short_name: "DONT_CARE",
            doc: Some(
                "The contents generated during the render pass are not needed and may be discarded. The contents will be undefined.\n",
            ),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STOREOP_RESOLVE",
            short_name: "RESOLVE",
            doc: Some(
                "The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture may then be discarded and will be undefined.\n",
            ),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STOREOP_RESOLVE_AND_STORE",
            short_name: "RESOLVE_AND_STORE",
            doc: Some(
                "The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture will be written to memory.\n",
            ),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUIndexElementSize: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUIndexElementSize",
    short_name: "GPUIndexElementSize",
    doc: Some(
        "Specifies the size of elements in an index buffer.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_INDEXELEMENTSIZE_16BIT",
            short_name: "_16BIT",
            doc: Some("The index elements are 16-bit.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_INDEXELEMENTSIZE_32BIT",
            short_name: "_32BIT",
            doc: Some("The index elements are 32-bit.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUTextureFormat: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUTextureFormat",
    short_name: "GPUTextureFormat",
    doc: Some(
        "Specifies the pixel format of a texture.\n\nTexture format support varies depending on driver, hardware, and usage\nflags. In general, you should use [`SDL_GPUTextureSupportsFormat`] to query if\na format is supported before using it. However, there are a few guaranteed\nformats.\n\nFIXME: Check universal support for 32-bit component formats FIXME: Check\nuniversal support for SIMULTANEOUS_READ_WRITE\n\nFor SAMPLER usage, the following formats are universally supported:\n\n- R8G8B8A8_UNORM\n- B8G8R8A8_UNORM\n- R8_UNORM\n- R8_SNORM\n- R8G8_UNORM\n- R8G8_SNORM\n- R8G8B8A8_SNORM\n- R16_FLOAT\n- R16G16_FLOAT\n- R16G16B16A16_FLOAT\n- R32_FLOAT\n- R32G32_FLOAT\n- R32G32B32A32_FLOAT\n- R11G11B10_UFLOAT\n- R8G8B8A8_UNORM_SRGB\n- B8G8R8A8_UNORM_SRGB\n- D16_UNORM\n\nFor COLOR_TARGET usage, the following formats are universally supported:\n\n- R8G8B8A8_UNORM\n- B8G8R8A8_UNORM\n- R8_UNORM\n- R16_FLOAT\n- R16G16_FLOAT\n- R16G16B16A16_FLOAT\n- R32_FLOAT\n- R32G32_FLOAT\n- R32G32B32A32_FLOAT\n- R8_UINT\n- R8G8_UINT\n- R8G8B8A8_UINT\n- R16_UINT\n- R16G16_UINT\n- R16G16B16A16_UINT\n- R8_INT\n- R8G8_INT\n- R8G8B8A8_INT\n- R16_INT\n- R16G16_INT\n- R16G16B16A16_INT\n- R8G8B8A8_UNORM_SRGB\n- B8G8R8A8_UNORM_SRGB\n\nFor STORAGE usages, the following formats are universally supported:\n\n- R8G8B8A8_UNORM\n- R8G8B8A8_SNORM\n- R16G16B16A16_FLOAT\n- R32_FLOAT\n- R32G32_FLOAT\n- R32G32B32A32_FLOAT\n- R8G8B8A8_UINT\n- R16G16B16A16_UINT\n- R8G8B8A8_INT\n- R16G16B16A16_INT\n\nFor DEPTH_STENCIL_TARGET usage, the following formats are universally\nsupported:\n\n- D16_UNORM\n- Either (but not necessarily both!) D24_UNORM or D32_FLOAT\n- Either (but not necessarily both!) D24_UNORM_S8_UINT or D32_FLOAT_S8_UINT\n\nUnless D16_UNORM is sufficient for your purposes, always check which of\nD24/D32 is supported before creating a depth-stencil texture!\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUTexture`]\n- [`SDL_GPUTextureSupportsFormat`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_INVALID",
            short_name: "INVALID",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_A8_UNORM",
            short_name: "A8_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8_UNORM",
            short_name: "R8_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8_UNORM",
            short_name: "R8G8_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM",
            short_name: "R8G8B8A8_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16_UNORM",
            short_name: "R16_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16_UNORM",
            short_name: "R16G16_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UNORM",
            short_name: "R16G16B16A16_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R10G10B10A2_UNORM",
            short_name: "R10G10B10A2_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_B5G6R5_UNORM",
            short_name: "B5G6R5_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_B5G5R5A1_UNORM",
            short_name: "B5G5R5A1_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_B4G4R4A4_UNORM",
            short_name: "B4G4R4A4_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM",
            short_name: "B8G8R8A8_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM",
            short_name: "BC1_RGBA_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM",
            short_name: "BC2_RGBA_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM",
            short_name: "BC3_RGBA_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC4_R_UNORM",
            short_name: "BC4_R_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC5_RG_UNORM",
            short_name: "BC5_RG_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM",
            short_name: "BC7_RGBA_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC6H_RGB_FLOAT",
            short_name: "BC6H_RGB_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC6H_RGB_UFLOAT",
            short_name: "BC6H_RGB_UFLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8_SNORM",
            short_name: "R8_SNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8_SNORM",
            short_name: "R8G8_SNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8B8A8_SNORM",
            short_name: "R8G8B8A8_SNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16_SNORM",
            short_name: "R16_SNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16_SNORM",
            short_name: "R16G16_SNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16B16A16_SNORM",
            short_name: "R16G16B16A16_SNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16_FLOAT",
            short_name: "R16_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16_FLOAT",
            short_name: "R16G16_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16B16A16_FLOAT",
            short_name: "R16G16B16A16_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32_FLOAT",
            short_name: "R32_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32G32_FLOAT",
            short_name: "R32G32_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32G32B32A32_FLOAT",
            short_name: "R32G32B32A32_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R11G11B10_UFLOAT",
            short_name: "R11G11B10_UFLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8_UINT",
            short_name: "R8_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8_UINT",
            short_name: "R8G8_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UINT",
            short_name: "R8G8B8A8_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16_UINT",
            short_name: "R16_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16_UINT",
            short_name: "R16G16_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16B16A16_UINT",
            short_name: "R16G16B16A16_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32_UINT",
            short_name: "R32_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32G32_UINT",
            short_name: "R32G32_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32G32B32A32_UINT",
            short_name: "R32G32B32A32_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8_INT",
            short_name: "R8_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8_INT",
            short_name: "R8G8_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8B8A8_INT",
            short_name: "R8G8B8A8_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16_INT",
            short_name: "R16_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16_INT",
            short_name: "R16G16_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R16G16B16A16_INT",
            short_name: "R16G16B16A16_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32_INT",
            short_name: "R32_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32G32_INT",
            short_name: "R32G32_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R32G32B32A32_INT",
            short_name: "R32G32B32A32_INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_R8G8B8A8_UNORM_SRGB",
            short_name: "R8G8B8A8_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_B8G8R8A8_UNORM_SRGB",
            short_name: "B8G8R8A8_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC1_RGBA_UNORM_SRGB",
            short_name: "BC1_RGBA_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC2_RGBA_UNORM_SRGB",
            short_name: "BC2_RGBA_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC3_RGBA_UNORM_SRGB",
            short_name: "BC3_RGBA_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_BC7_RGBA_UNORM_SRGB",
            short_name: "BC7_RGBA_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_D16_UNORM",
            short_name: "D16_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_D24_UNORM",
            short_name: "D24_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_D32_FLOAT",
            short_name: "D32_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_D24_UNORM_S8_UINT",
            short_name: "D24_UNORM_S8_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_D32_FLOAT_S8_UINT",
            short_name: "D32_FLOAT_S8_UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM",
            short_name: "ASTC_4x4_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM",
            short_name: "ASTC_5x4_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM",
            short_name: "ASTC_5x5_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM",
            short_name: "ASTC_6x5_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM",
            short_name: "ASTC_6x6_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM",
            short_name: "ASTC_8x5_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM",
            short_name: "ASTC_8x6_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM",
            short_name: "ASTC_8x8_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM",
            short_name: "ASTC_10x5_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM",
            short_name: "ASTC_10x6_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM",
            short_name: "ASTC_10x8_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM",
            short_name: "ASTC_10x10_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM",
            short_name: "ASTC_12x10_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM",
            short_name: "ASTC_12x12_UNORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_4x4_UNORM_SRGB",
            short_name: "ASTC_4x4_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_5x4_UNORM_SRGB",
            short_name: "ASTC_5x4_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_5x5_UNORM_SRGB",
            short_name: "ASTC_5x5_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_6x5_UNORM_SRGB",
            short_name: "ASTC_6x5_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_6x6_UNORM_SRGB",
            short_name: "ASTC_6x6_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x5_UNORM_SRGB",
            short_name: "ASTC_8x5_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x6_UNORM_SRGB",
            short_name: "ASTC_8x6_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x8_UNORM_SRGB",
            short_name: "ASTC_8x8_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x5_UNORM_SRGB",
            short_name: "ASTC_10x5_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x6_UNORM_SRGB",
            short_name: "ASTC_10x6_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x8_UNORM_SRGB",
            short_name: "ASTC_10x8_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x10_UNORM_SRGB",
            short_name: "ASTC_10x10_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_12x10_UNORM_SRGB",
            short_name: "ASTC_12x10_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_12x12_UNORM_SRGB",
            short_name: "ASTC_12x12_UNORM_SRGB",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_4x4_FLOAT",
            short_name: "ASTC_4x4_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_5x4_FLOAT",
            short_name: "ASTC_5x4_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_5x5_FLOAT",
            short_name: "ASTC_5x5_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_6x5_FLOAT",
            short_name: "ASTC_6x5_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_6x6_FLOAT",
            short_name: "ASTC_6x6_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x5_FLOAT",
            short_name: "ASTC_8x5_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x6_FLOAT",
            short_name: "ASTC_8x6_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_8x8_FLOAT",
            short_name: "ASTC_8x8_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x5_FLOAT",
            short_name: "ASTC_10x5_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x6_FLOAT",
            short_name: "ASTC_10x6_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x8_FLOAT",
            short_name: "ASTC_10x8_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_10x10_FLOAT",
            short_name: "ASTC_10x10_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_12x10_FLOAT",
            short_name: "ASTC_12x10_FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREFORMAT_ASTC_12x12_FLOAT",
            short_name: "ASTC_12x12_FLOAT",
            doc: None,
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUTextureUsageFlags: Group = Group {
    module: "gpu",
    kind: GroupKind::Flags,
    name: "SDL_GPUTextureUsageFlags",
    short_name: "GPUTextureUsageFlags",
    doc: Some(
        "Specifies how a texture is intended to be used by the client.\n\nA texture must have at least one usage flag. Note that some usage flag\ncombinations are invalid.\n\nWith regards to compute storage usage, READ | WRITE means that you can have\nshader A that only writes into the texture and shader B that only reads\nfrom the texture and bind the same texture to either shader respectively.\nSIMULTANEOUS means that you can do reads and writes within the same shader\nor compute pass. It also implies that atomic ops can be used, since those\nare read-modify-write operations. If you use SIMULTANEOUS, you are\nresponsible for avoiding data races, as there is no data synchronization\nwithin a compute pass. Note that SIMULTANEOUS usage is only supported by a\nlimited number of texture formats.\n\n## Availability\nThis datatype is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUTexture`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_TEXTUREUSAGE_SAMPLER",
            short_name: "SAMPLER",
            doc: Some("Texture supports sampling.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREUSAGE_COLOR_TARGET",
            short_name: "COLOR_TARGET",
            doc: Some("Texture is a color render target.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET",
            short_name: "DEPTH_STENCIL_TARGET",
            doc: Some("Texture is a depth stencil target.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ",
            short_name: "GRAPHICS_STORAGE_READ",
            doc: Some("Texture supports storage reads in graphics stages.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ",
            short_name: "COMPUTE_STORAGE_READ",
            doc: Some("Texture supports storage reads in the compute stage.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE",
            short_name: "COMPUTE_STORAGE_WRITE",
            doc: Some("Texture supports storage writes in the compute stage.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE",
            short_name: "COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE",
            doc: Some(
                "Texture supports reads and writes in the same compute shader. This is NOT equivalent to READ | WRITE.\n",
            ),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUTextureType: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUTextureType",
    short_name: "GPUTextureType",
    doc: Some(
        "Specifies the type of a texture.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUTexture`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_TEXTURETYPE_2D",
            short_name: "_2D",
            doc: Some("The texture is a 2-dimensional image.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTURETYPE_2D_ARRAY",
            short_name: "_2D_ARRAY",
            doc: Some("The texture is a 2-dimensional array image.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTURETYPE_3D",
            short_name: "_3D",
            doc: Some("The texture is a 3-dimensional image.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTURETYPE_CUBE",
            short_name: "CUBE",
            doc: Some("The texture is a cube image.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TEXTURETYPE_CUBE_ARRAY",
            short_name: "CUBE_ARRAY",
            doc: Some("The texture is a cube array image.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUSampleCount: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUSampleCount",
    short_name: "GPUSampleCount",
    doc: Some(
        "Specifies the sample count of a texture.\n\nUsed in multisampling. Note that this value only applies when the texture\nis used as a render target.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUTexture`]\n- [`SDL_GPUTextureSupportsSampleCount`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_SAMPLECOUNT_1",
            short_name: "_1",
            doc: Some("No multisampling.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SAMPLECOUNT_2",
            short_name: "_2",
            doc: Some("MSAA 2x\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SAMPLECOUNT_4",
            short_name: "_4",
            doc: Some("MSAA 4x\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SAMPLECOUNT_8",
            short_name: "_8",
            doc: Some("MSAA 8x\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUCubeMapFace: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUCubeMapFace",
    short_name: "GPUCubeMapFace",
    doc: Some(
        "Specifies the face of a cube map.\n\nCan be passed in as the layer field in texture-related structs.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_CUBEMAPFACE_POSITIVEX",
            short_name: "POSITIVEX",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_CUBEMAPFACE_NEGATIVEX",
            short_name: "NEGATIVEX",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_CUBEMAPFACE_POSITIVEY",
            short_name: "POSITIVEY",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_CUBEMAPFACE_NEGATIVEY",
            short_name: "NEGATIVEY",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_CUBEMAPFACE_POSITIVEZ",
            short_name: "POSITIVEZ",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_CUBEMAPFACE_NEGATIVEZ",
            short_name: "NEGATIVEZ",
            doc: None,
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUBufferUsageFlags: Group = Group {
    module: "gpu",
    kind: GroupKind::Flags,
    name: "SDL_GPUBufferUsageFlags",
    short_name: "GPUBufferUsageFlags",
    doc: Some(
        "Specifies how a buffer is intended to be used by the client.\n\nA buffer must have at least one usage flag. Note that some usage flag\ncombinations are invalid.\n\nUnlike textures, READ | WRITE can be used for simultaneous read-write\nusage. The same data synchronization concerns as textures apply.\n\nIf you use a STORAGE flag, the data in the buffer must respect std140\nlayout conventions. In practical terms this means you must ensure that vec3\nand vec4 fields are 16-byte aligned.\n\n## Availability\nThis datatype is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUBuffer`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_BUFFERUSAGE_VERTEX",
            short_name: "VERTEX",
            doc: Some("Buffer is a vertex buffer.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BUFFERUSAGE_INDEX",
            short_name: "INDEX",
            doc: Some("Buffer is an index buffer.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BUFFERUSAGE_INDIRECT",
            short_name: "INDIRECT",
            doc: Some("Buffer is an indirect buffer.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ",
            short_name: "GRAPHICS_STORAGE_READ",
            doc: Some("Buffer supports storage reads in graphics stages.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ",
            short_name: "COMPUTE_STORAGE_READ",
            doc: Some("Buffer supports storage reads in the compute stage.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE",
            short_name: "COMPUTE_STORAGE_WRITE",
            doc: Some("Buffer supports storage writes in the compute stage.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUTransferBufferUsage: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUTransferBufferUsage",
    short_name: "GPUTransferBufferUsage",
    doc: Some(
        "Specifies how a transfer buffer is intended to be used by the client.\n\nNote that mapping and copying FROM an upload transfer buffer or TO a\ndownload transfer buffer is undefined behavior.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUTransferBuffer`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_TRANSFERBUFFERUSAGE_UPLOAD",
            short_name: "UPLOAD",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_TRANSFERBUFFERUSAGE_DOWNLOAD",
            short_name: "DOWNLOAD",
            doc: None,
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUShaderStage: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUShaderStage",
    short_name: "GPUShaderStage",
    doc: Some(
        "Specifies which stage a shader program corresponds to.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUShader`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_SHADERSTAGE_VERTEX",
            short_name: "VERTEX",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SHADERSTAGE_FRAGMENT",
            short_name: "FRAGMENT",
            doc: None,
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUShaderFormat: Group = Group {
    module: "gpu",
    kind: GroupKind::Flags,
    name: "SDL_GPUShaderFormat",
    short_name: "GPUShaderFormat",
    doc: Some(
        "Specifies the format of shader code.\n\nEach format corresponds to a specific backend that accepts it.\n\n## Availability\nThis datatype is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUShader`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_SHADERFORMAT_INVALID",
            short_name: "INVALID",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SHADERFORMAT_PRIVATE",
            short_name: "PRIVATE",
            doc: Some("Shaders for NDA'd platforms.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SHADERFORMAT_SPIRV",
            short_name: "SPIRV",
            doc: Some("SPIR-V shaders for Vulkan.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SHADERFORMAT_DXBC",
            short_name: "DXBC",
            doc: Some("DXBC SM5_1 shaders for D3D12.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SHADERFORMAT_DXIL",
            short_name: "DXIL",
            doc: Some("DXIL SM6_0 shaders for D3D12.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SHADERFORMAT_MSL",
            short_name: "MSL",
            doc: Some("MSL shaders for Metal.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SHADERFORMAT_METALLIB",
            short_name: "METALLIB",
            doc: Some("Precompiled metallib shaders for Metal.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUVertexElementFormat: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUVertexElementFormat",
    short_name: "GPUVertexElementFormat",
    doc: Some(
        "Specifies the format of a vertex attribute.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_INVALID",
            short_name: "INVALID",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_INT",
            short_name: "INT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_INT2",
            short_name: "INT2",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_INT3",
            short_name: "INT3",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_INT4",
            short_name: "INT4",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_UINT",
            short_name: "UINT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_UINT2",
            short_name: "UINT2",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_UINT3",
            short_name: "UINT3",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_UINT4",
            short_name: "UINT4",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_FLOAT",
            short_name: "FLOAT",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_FLOAT2",
            short_name: "FLOAT2",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_FLOAT3",
            short_name: "FLOAT3",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_FLOAT4",
            short_name: "FLOAT4",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_BYTE2",
            short_name: "BYTE2",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_BYTE4",
            short_name: "BYTE4",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2",
            short_name: "UBYTE2",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4",
            short_name: "UBYTE4",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_BYTE2_NORM",
            short_name: "BYTE2_NORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_BYTE4_NORM",
            short_name: "BYTE4_NORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_UBYTE2_NORM",
            short_name: "UBYTE2_NORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_UBYTE4_NORM",
            short_name: "UBYTE4_NORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_SHORT2",
            short_name: "SHORT2",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_SHORT4",
            short_name: "SHORT4",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_USHORT2",
            short_name: "USHORT2",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_USHORT4",
            short_name: "USHORT4",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_SHORT2_NORM",
            short_name: "SHORT2_NORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_SHORT4_NORM",
            short_name: "SHORT4_NORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_USHORT2_NORM",
            short_name: "USHORT2_NORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_USHORT4_NORM",
            short_name: "USHORT4_NORM",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_HALF2",
            short_name: "HALF2",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXELEMENTFORMAT_HALF4",
            short_name: "HALF4",
            doc: None,
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUVertexInputRate: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUVertexInputRate",
    short_name: "GPUVertexInputRate",
    doc: Some(
        "Specifies the rate at which vertex attributes are pulled from buffers.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_VERTEXINPUTRATE_VERTEX",
            short_name: "VERTEX",
            doc: Some("Attribute addressing is a function of the vertex index.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_VERTEXINPUTRATE_INSTANCE",
            short_name: "INSTANCE",
            doc: Some("Attribute addressing is a function of the instance index.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUFillMode: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUFillMode",
    short_name: "GPUFillMode",
    doc: Some(
        "Specifies the fill mode of the graphics pipeline.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_FILLMODE_FILL",
            short_name: "FILL",
            doc: Some("Polygons will be rendered via rasterization.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_FILLMODE_LINE",
            short_name: "LINE",
            doc: Some("Polygon edges will be drawn as line segments.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUCullMode: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUCullMode",
    short_name: "GPUCullMode",
    doc: Some(
        "Specifies the facing direction in which triangle faces will be culled.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_CULLMODE_NONE",
            short_name: "NONE",
            doc: Some("No triangles are culled.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_CULLMODE_FRONT",
            short_name: "FRONT",
            doc: Some("Front-facing triangles are culled.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_CULLMODE_BACK",
            short_name: "BACK",
            doc: Some("Back-facing triangles are culled.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUFrontFace: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUFrontFace",
    short_name: "GPUFrontFace",
    doc: Some(
        "Specifies the vertex winding that will cause a triangle to be determined to\nbe front-facing.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_FRONTFACE_COUNTER_CLOCKWISE",
            short_name: "COUNTER_CLOCKWISE",
            doc: Some(
                "A triangle with counter-clockwise vertex winding will be considered front-facing.\n",
            ),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_FRONTFACE_CLOCKWISE",
            short_name: "CLOCKWISE",
            doc: Some(
                "A triangle with clockwise vertex winding will be considered front-facing.\n",
            ),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUCompareOp: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUCompareOp",
    short_name: "GPUCompareOp",
    doc: Some(
        "Specifies a comparison operator for depth, stencil and sampler operations.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_COMPAREOP_INVALID",
            short_name: "INVALID",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COMPAREOP_NEVER",
            short_name: "NEVER",
            doc: Some("The comparison always evaluates false.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COMPAREOP_LESS",
            short_name: "LESS",
            doc: Some("The comparison evaluates reference < test.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COMPAREOP_EQUAL",
            short_name: "EQUAL",
            doc: Some("The comparison evaluates reference == test.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COMPAREOP_LESS_OR_EQUAL",
            short_name: "LESS_OR_EQUAL",
            doc: Some("The comparison evaluates reference <= test.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COMPAREOP_GREATER",
            short_name: "GREATER",
            doc: Some("The comparison evaluates reference > test.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COMPAREOP_NOT_EQUAL",
            short_name: "NOT_EQUAL",
            doc: Some("The comparison evaluates reference != test.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COMPAREOP_GREATER_OR_EQUAL",
            short_name: "GREATER_OR_EQUAL",
            doc: Some("The comparison evaluates reference >= test.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COMPAREOP_ALWAYS",
            short_name: "ALWAYS",
            doc: Some("The comparison always evaluates true.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUStencilOp: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUStencilOp",
    short_name: "GPUStencilOp",
    doc: Some(
        "Specifies what happens to a stored stencil value if stencil tests fail or\npass.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_STENCILOP_INVALID",
            short_name: "INVALID",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STENCILOP_KEEP",
            short_name: "KEEP",
            doc: Some("Keeps the current value.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STENCILOP_ZERO",
            short_name: "ZERO",
            doc: Some("Sets the value to 0.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STENCILOP_REPLACE",
            short_name: "REPLACE",
            doc: Some("Sets the value to reference.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STENCILOP_INCREMENT_AND_CLAMP",
            short_name: "INCREMENT_AND_CLAMP",
            doc: Some("Increments the current value and clamps to the maximum value.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STENCILOP_DECREMENT_AND_CLAMP",
            short_name: "DECREMENT_AND_CLAMP",
            doc: Some("Decrements the current value and clamps to 0.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STENCILOP_INVERT",
            short_name: "INVERT",
            doc: Some("Bitwise-inverts the current value.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STENCILOP_INCREMENT_AND_WRAP",
            short_name: "INCREMENT_AND_WRAP",
            doc: Some("Increments the current value and wraps back to 0.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_STENCILOP_DECREMENT_AND_WRAP",
            short_name: "DECREMENT_AND_WRAP",
            doc: Some("Decrements the current value and wraps to the maximum value.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUBlendOp: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUBlendOp",
    short_name: "GPUBlendOp",
    doc: Some(
        "Specifies the operator to be used when pixels in a render target are\nblended with existing pixels in the texture.\n\nThe source color is the value written by the fragment shader. The\ndestination color is the value currently existing in the texture.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_BLENDOP_INVALID",
            short_name: "INVALID",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDOP_ADD",
            short_name: "ADD",
            doc: Some("(source * source_factor) + (destination * destination_factor)\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDOP_SUBTRACT",
            short_name: "SUBTRACT",
            doc: Some("(source * source_factor) - (destination * destination_factor)\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDOP_REVERSE_SUBTRACT",
            short_name: "REVERSE_SUBTRACT",
            doc: Some("(destination * destination_factor) - (source * source_factor)\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDOP_MIN",
            short_name: "MIN",
            doc: Some("min(source, destination)\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDOP_MAX",
            short_name: "MAX",
            doc: Some("max(source, destination)\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUBlendFactor: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUBlendFactor",
    short_name: "GPUBlendFactor",
    doc: Some(
        "Specifies a blending factor to be used when pixels in a render target are\nblended with existing pixels in the texture.\n\nThe source color is the value written by the fragment shader. The\ndestination color is the value currently existing in the texture.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_INVALID",
            short_name: "INVALID",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_ZERO",
            short_name: "ZERO",
            doc: Some("0\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_ONE",
            short_name: "ONE",
            doc: Some("1\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_SRC_COLOR",
            short_name: "SRC_COLOR",
            doc: Some("source color\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_COLOR",
            short_name: "ONE_MINUS_SRC_COLOR",
            doc: Some("1 - source color\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_DST_COLOR",
            short_name: "DST_COLOR",
            doc: Some("destination color\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_COLOR",
            short_name: "ONE_MINUS_DST_COLOR",
            doc: Some("1 - destination color\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_SRC_ALPHA",
            short_name: "SRC_ALPHA",
            doc: Some("source alpha\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_ONE_MINUS_SRC_ALPHA",
            short_name: "ONE_MINUS_SRC_ALPHA",
            doc: Some("1 - source alpha\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_DST_ALPHA",
            short_name: "DST_ALPHA",
            doc: Some("destination alpha\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_ONE_MINUS_DST_ALPHA",
            short_name: "ONE_MINUS_DST_ALPHA",
            doc: Some("1 - destination alpha\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_CONSTANT_COLOR",
            short_name: "CONSTANT_COLOR",
            doc: Some("blend constant\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR",
            short_name: "ONE_MINUS_CONSTANT_COLOR",
            doc: Some("1 - blend constant\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_BLENDFACTOR_SRC_ALPHA_SATURATE",
            short_name: "SRC_ALPHA_SATURATE",
            doc: Some("min(source alpha, 1 - destination alpha)\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUColorComponentFlags: Group = Group {
    module: "gpu",
    kind: GroupKind::Flags,
    name: "SDL_GPUColorComponentFlags",
    short_name: "GPUColorComponentFlags",
    doc: Some(
        "Specifies which color components are written in a graphics pipeline.\n\n## Availability\nThis datatype is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_COLORCOMPONENT_R",
            short_name: "R",
            doc: Some("the red component\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COLORCOMPONENT_G",
            short_name: "G",
            doc: Some("the green component\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COLORCOMPONENT_B",
            short_name: "B",
            doc: Some("the blue component\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_COLORCOMPONENT_A",
            short_name: "A",
            doc: Some("the alpha component\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUFilter: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUFilter",
    short_name: "GPUFilter",
    doc: Some(
        "Specifies a filter operation used by a sampler.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUSampler`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_FILTER_NEAREST",
            short_name: "NEAREST",
            doc: Some("Point filtering.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_FILTER_LINEAR",
            short_name: "LINEAR",
            doc: Some("Linear filtering.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUSamplerMipmapMode: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUSamplerMipmapMode",
    short_name: "GPUSamplerMipmapMode",
    doc: Some(
        "Specifies a mipmap mode used by a sampler.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUSampler`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_SAMPLERMIPMAPMODE_NEAREST",
            short_name: "NEAREST",
            doc: Some("Point filtering.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SAMPLERMIPMAPMODE_LINEAR",
            short_name: "LINEAR",
            doc: Some("Linear filtering.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUSamplerAddressMode: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUSamplerAddressMode",
    short_name: "GPUSamplerAddressMode",
    doc: Some(
        "Specifies behavior of texture sampling when the coordinates exceed the 0-1\nrange.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUSampler`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_SAMPLERADDRESSMODE_REPEAT",
            short_name: "REPEAT",
            doc: Some("Specifies that the coordinates will wrap around.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SAMPLERADDRESSMODE_MIRRORED_REPEAT",
            short_name: "MIRRORED_REPEAT",
            doc: Some("Specifies that the coordinates will wrap around mirrored.\n"),
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SAMPLERADDRESSMODE_CLAMP_TO_EDGE",
            short_name: "CLAMP_TO_EDGE",
            doc: Some("Specifies that the coordinates will clamp to the 0-1 range.\n"),
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUPresentMode: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUPresentMode",
    short_name: "GPUPresentMode",
    doc: Some(
        "Specifies the timing that will be used to present swapchain textures to the\nOS.\n\nVSYNC mode will always be supported. IMMEDIATE and MAILBOX modes may not be\nsupported on certain systems.\n\nIt is recommended to query [`SDL_WindowSupportsGPUPresentMode`] after claiming\nthe window if you wish to change the present mode to IMMEDIATE or MAILBOX.\n\n- VSYNC: Waits for vblank before presenting. No tearing is possible. If\nthere is a pending image to present, the new image is enqueued for\npresentation. Disallows tearing at the cost of visual latency.\n- IMMEDIATE: Immediately presents. Lowest latency option, but tearing may\noccur.\n- MAILBOX: Waits for vblank before presenting. No tearing is possible. If\nthere is a pending image to present, the pending image is replaced by the\nnew image. Similar to VSYNC, but with reduced visual latency.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_SetGPUSwapchainParameters`]\n- [`SDL_WindowSupportsGPUPresentMode`]\n- [`SDL_WaitAndAcquireGPUSwapchainTexture`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_PRESENTMODE_VSYNC",
            short_name: "VSYNC",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_PRESENTMODE_IMMEDIATE",
            short_name: "IMMEDIATE",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_PRESENTMODE_MAILBOX",
            short_name: "MAILBOX",
            doc: None,
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUSwapchainComposition: Group = Group {
    module: "gpu",
    kind: GroupKind::Enum,
    name: "SDL_GPUSwapchainComposition",
    short_name: "GPUSwapchainComposition",
    doc: Some(
        "Specifies the texture format and colorspace of the swapchain textures.\n\nSDR will always be supported. Other compositions may not be supported on\ncertain systems.\n\nIt is recommended to query [`SDL_WindowSupportsGPUSwapchainComposition`] after\nclaiming the window if you wish to change the swapchain composition from\nSDR.\n\n- SDR: B8G8R8A8 or R8G8B8A8 swapchain. Pixel values are in sRGB encoding.\n- SDR_LINEAR: B8G8R8A8_SRGB or R8G8B8A8_SRGB swapchain. Pixel values are\nstored in memory in sRGB encoding but accessed in shaders in \"linear\nsRGB\" encoding which is sRGB but with a linear transfer function.\n- HDR_EXTENDED_LINEAR: R16G16B16A16_FLOAT swapchain. Pixel values are in\nextended linear sRGB encoding and permits values outside of the \\[0, 1\\]\nrange.\n- HDR10_ST2084: A2R10G10B10 or A2B10G10R10 swapchain. Pixel values are in\nBT.2020 ST2084 (PQ) encoding.\n\n## Availability\nThis enum is available since SDL 3.2.0.\n\n## See also\n- [`SDL_SetGPUSwapchainParameters`]\n- [`SDL_WindowSupportsGPUSwapchainComposition`]\n- [`SDL_WaitAndAcquireGPUSwapchainTexture`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    values: &[
        GroupValue {
            name: "SDL_GPU_SWAPCHAINCOMPOSITION_SDR",
            short_name: "SDR",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SWAPCHAINCOMPOSITION_SDR_LINEAR",
            short_name: "SDR_LINEAR",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SWAPCHAINCOMPOSITION_HDR_EXTENDED_LINEAR",
            short_name: "HDR_EXTENDED_LINEAR",
            doc: None,
            available_since: None,
        },
        GroupValue {
            name: "SDL_GPU_SWAPCHAINCOMPOSITION_HDR10_ST2084",
            short_name: "HDR10_ST2084",
            doc: None,
            available_since: None,
        },
    ],
};
pub const METADATA_SDL_GPUViewport: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUViewport",
    doc: Some(
        "A structure specifying a viewport.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_SetGPUViewport`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "x",
            doc: Some("The left offset of the viewport.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "y",
            doc: Some("The top offset of the viewport.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "w",
            doc: Some("The width of the viewport.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "h",
            doc: Some("The height of the viewport.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "min_depth",
            doc: Some("The minimum depth of the viewport.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "max_depth",
            doc: Some("The maximum depth of the viewport.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
    ],
};
pub const METADATA_SDL_GPUTextureTransferInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUTextureTransferInfo",
    doc: Some(
        "A structure specifying parameters related to transferring data to or from a\ntexture.\n\nIf either of `pixels_per_row` or `rows_per_layer` is zero, then width and\nheight of passed [`SDL_GPUTextureRegion`] to [`SDL_UploadToGPUTexture`] or\n[`SDL_DownloadFromGPUTexture`] are used as default values respectively and data\nis considered to be tightly packed.\n\n**WARNING**: Direct3D 12 requires texture data row pitch to be 256 byte\naligned, and offsets to be aligned to 512 bytes. If they are not, SDL will\nmake a temporary copy of the data that is properly aligned, but this adds\noverhead to the transfer process. Apps can avoid this by aligning their\ndata appropriately, or using a different GPU backend than Direct3D 12.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_UploadToGPUTexture`]\n- [`SDL_DownloadFromGPUTexture`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "transfer_buffer",
            doc: Some("The transfer buffer used in the transfer operation.\n"),
            available_since: None,
            ty: "*mut SDL_GPUTransferBuffer",
        },
        Field {
            name: "offset",
            doc: Some("The starting byte of the image data in the transfer buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "pixels_per_row",
            doc: Some("The number of pixels from one row to the next.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "rows_per_layer",
            doc: Some("The number of rows from one layer/depth-slice to the next.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUTransferBufferLocation: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUTransferBufferLocation",
    doc: Some(
        "A structure specifying a location in a transfer buffer.\n\nUsed when transferring buffer data to or from a transfer buffer.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_UploadToGPUBuffer`]\n- [`SDL_DownloadFromGPUBuffer`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "transfer_buffer",
            doc: Some("The transfer buffer used in the transfer operation.\n"),
            available_since: None,
            ty: "*mut SDL_GPUTransferBuffer",
        },
        Field {
            name: "offset",
            doc: Some("The starting byte of the buffer data in the transfer buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUTextureLocation: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUTextureLocation",
    doc: Some(
        "A structure specifying a location in a texture.\n\nUsed when copying data from one texture to another.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CopyGPUTextureToTexture`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "texture",
            doc: Some("The texture used in the copy operation.\n"),
            available_since: None,
            ty: "*mut SDL_GPUTexture",
        },
        Field {
            name: "mip_level",
            doc: Some("The mip level index of the location.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "layer",
            doc: Some("The layer index of the location.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "x",
            doc: Some("The left offset of the location.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "y",
            doc: Some("The top offset of the location.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "z",
            doc: Some("The front offset of the location.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUTextureRegion: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUTextureRegion",
    doc: Some(
        "A structure specifying a region of a texture.\n\nUsed when transferring data to or from a texture.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_UploadToGPUTexture`]\n- [`SDL_DownloadFromGPUTexture`]\n- [`SDL_CreateGPUTexture`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "texture",
            doc: Some("The texture used in the copy operation.\n"),
            available_since: None,
            ty: "*mut SDL_GPUTexture",
        },
        Field {
            name: "mip_level",
            doc: Some("The mip level index to transfer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "layer",
            doc: Some("The layer index to transfer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "x",
            doc: Some("The left offset of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "y",
            doc: Some("The top offset of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "z",
            doc: Some("The front offset of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "w",
            doc: Some("The width of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "h",
            doc: Some("The height of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "d",
            doc: Some("The depth of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUBlitRegion: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUBlitRegion",
    doc: Some(
        "A structure specifying a region of a texture used in the blit operation.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BlitGPUTexture`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "texture",
            doc: Some("The texture.\n"),
            available_since: None,
            ty: "*mut SDL_GPUTexture",
        },
        Field {
            name: "mip_level",
            doc: Some("The mip level index of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "layer_or_depth_plane",
            doc: Some(
                "The layer index or depth plane of the region. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "x",
            doc: Some("The left offset of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "y",
            doc: Some("The top offset of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "w",
            doc: Some("The width of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "h",
            doc: Some("The height of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUBufferLocation: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUBufferLocation",
    doc: Some(
        "A structure specifying a location in a buffer.\n\nUsed when copying data between buffers.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CopyGPUBufferToBuffer`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "buffer",
            doc: Some("The buffer.\n"),
            available_since: None,
            ty: "*mut SDL_GPUBuffer",
        },
        Field {
            name: "offset",
            doc: Some("The starting byte within the buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUBufferRegion: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUBufferRegion",
    doc: Some(
        "A structure specifying a region of a buffer.\n\nUsed when transferring data to or from buffers.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_UploadToGPUBuffer`]\n- [`SDL_DownloadFromGPUBuffer`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "buffer",
            doc: Some("The buffer.\n"),
            available_since: None,
            ty: "*mut SDL_GPUBuffer",
        },
        Field {
            name: "offset",
            doc: Some("The starting byte within the buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "size",
            doc: Some("The size in bytes of the region.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUIndirectDrawCommand: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUIndirectDrawCommand",
    doc: Some(
        "A structure specifying the parameters of an indirect draw command.\n\nNote that the `first_vertex` and `first_instance` parameters are NOT\ncompatible with built-in vertex/instance ID variables in shaders (for\nexample, SV_VertexID); GPU APIs and shader languages do not define these\nbuilt-in variables consistently, so if your shader depends on them, the\nonly way to keep behavior consistent and portable is to always pass 0 for\nthe correlating parameter in the draw calls.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_DrawGPUPrimitivesIndirect`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "num_vertices",
            doc: Some("The number of vertices to draw.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_instances",
            doc: Some("The number of instances to draw.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "first_vertex",
            doc: Some("The index of the first vertex to draw.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "first_instance",
            doc: Some("The ID of the first instance to draw.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUIndexedIndirectDrawCommand: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUIndexedIndirectDrawCommand",
    doc: Some(
        "A structure specifying the parameters of an indexed indirect draw command.\n\nNote that the `first_vertex` and `first_instance` parameters are NOT\ncompatible with built-in vertex/instance ID variables in shaders (for\nexample, SV_VertexID); GPU APIs and shader languages do not define these\nbuilt-in variables consistently, so if your shader depends on them, the\nonly way to keep behavior consistent and portable is to always pass 0 for\nthe correlating parameter in the draw calls.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_DrawGPUIndexedPrimitivesIndirect`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "num_indices",
            doc: Some("The number of indices to draw per instance.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_instances",
            doc: Some("The number of instances to draw.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "first_index",
            doc: Some("The base index within the index buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "vertex_offset",
            doc: Some(
                "The value added to the vertex index before indexing into the vertex buffer.\n",
            ),
            available_since: None,
            ty: "Sint32",
        },
        Field {
            name: "first_instance",
            doc: Some("The ID of the first instance to draw.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUIndirectDispatchCommand: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUIndirectDispatchCommand",
    doc: Some(
        "A structure specifying the parameters of an indexed dispatch command.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_DispatchGPUComputeIndirect`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "groupcount_x",
            doc: Some("The number of local workgroups to dispatch in the X dimension.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "groupcount_y",
            doc: Some("The number of local workgroups to dispatch in the Y dimension.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "groupcount_z",
            doc: Some("The number of local workgroups to dispatch in the Z dimension.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUSamplerCreateInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUSamplerCreateInfo",
    doc: Some(
        "A structure specifying the parameters of a sampler.\n\nNote that mip_lod_bias is a no-op for the Metal driver. For Metal, LOD bias\nmust be applied via shader instead.\n\n## Availability\nThis function is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUSampler`]\n- [`SDL_GPUFilter`]\n- [`SDL_GPUSamplerMipmapMode`]\n- [`SDL_GPUSamplerAddressMode`]\n- [`SDL_GPUCompareOp`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "min_filter",
            doc: Some("The minification filter to apply to lookups.\n"),
            available_since: None,
            ty: "SDL_GPUFilter",
        },
        Field {
            name: "mag_filter",
            doc: Some("The magnification filter to apply to lookups.\n"),
            available_since: None,
            ty: "SDL_GPUFilter",
        },
        Field {
            name: "mipmap_mode",
            doc: Some("The mipmap filter to apply to lookups.\n"),
            available_since: None,
            ty: "SDL_GPUSamplerMipmapMode",
        },
        Field {
            name: "address_mode_u",
            doc: Some("The addressing mode for U coordinates outside [0, 1).\n"),
            available_since: None,
            ty: "SDL_GPUSamplerAddressMode",
        },
        Field {
            name: "address_mode_v",
            doc: Some("The addressing mode for V coordinates outside [0, 1).\n"),
            available_since: None,
            ty: "SDL_GPUSamplerAddressMode",
        },
        Field {
            name: "address_mode_w",
            doc: Some("The addressing mode for W coordinates outside [0, 1).\n"),
            available_since: None,
            ty: "SDL_GPUSamplerAddressMode",
        },
        Field {
            name: "mip_lod_bias",
            doc: Some("The bias to be added to mipmap LOD calculation.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "max_anisotropy",
            doc: Some(
                "The anisotropy value clamp used by the sampler. If enable_anisotropy is false, this is ignored.\n",
            ),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "compare_op",
            doc: Some("The comparison operator to apply to fetched data before filtering.\n"),
            available_since: None,
            ty: "SDL_GPUCompareOp",
        },
        Field {
            name: "min_lod",
            doc: Some("Clamps the minimum of the computed LOD value.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "max_lod",
            doc: Some("Clamps the maximum of the computed LOD value.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "enable_anisotropy",
            doc: Some("true to enable anisotropic filtering.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "enable_compare",
            doc: Some("true to enable comparison against a reference value during lookups.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "props",
            doc: Some("A properties ID for extensions. Should be 0 if no extensions are needed.\n"),
            available_since: None,
            ty: "SDL_PropertiesID",
        },
    ],
};
pub const METADATA_SDL_GPUVertexBufferDescription: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUVertexBufferDescription",
    doc: Some(
        "A structure specifying the parameters of vertex buffers used in a graphics\npipeline.\n\nWhen you call [`SDL_BindGPUVertexBuffers`], you specify the binding slots of\nthe vertex buffers. For example if you called [`SDL_BindGPUVertexBuffers`] with\na first_slot of 2 and num_bindings of 3, the binding slots 2, 3, 4 would be\nused by the vertex buffers you pass in.\n\nVertex attributes are linked to buffers via the buffer_slot field of\n[`SDL_GPUVertexAttribute`]. For example, if an attribute has a buffer_slot of\n0, then that attribute belongs to the vertex buffer bound at slot 0.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUVertexAttribute`]\n- [`SDL_GPUVertexInputRate`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "slot",
            doc: Some("The binding slot of the vertex buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "pitch",
            doc: Some("The size of a single element + the offset between elements.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "input_rate",
            doc: Some(
                "Whether attribute addressing is a function of the vertex index or instance index.\n",
            ),
            available_since: None,
            ty: "SDL_GPUVertexInputRate",
        },
        Field {
            name: "instance_step_rate",
            doc: Some("Reserved for future use. Must be set to 0.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUVertexAttribute: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUVertexAttribute",
    doc: Some(
        "A structure specifying a vertex attribute.\n\nAll vertex attribute locations provided to an [`SDL_GPUVertexInputState`] must\nbe unique.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUVertexBufferDescription`]\n- [`SDL_GPUVertexInputState`]\n- [`SDL_GPUVertexElementFormat`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "location",
            doc: Some("The shader input location index.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "buffer_slot",
            doc: Some("The binding slot of the associated vertex buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "format",
            doc: Some("The size and type of the attribute data.\n"),
            available_since: None,
            ty: "SDL_GPUVertexElementFormat",
        },
        Field {
            name: "offset",
            doc: Some(
                "The byte offset of this attribute relative to the start of the vertex element.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUVertexInputState: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUVertexInputState",
    doc: Some(
        "A structure specifying the parameters of a graphics pipeline vertex input\nstate.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUGraphicsPipelineCreateInfo`]\n- [`SDL_GPUVertexBufferDescription`]\n- [`SDL_GPUVertexAttribute`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "vertex_buffer_descriptions",
            doc: Some("A pointer to an array of vertex buffer descriptions.\n"),
            available_since: None,
            ty: "*const SDL_GPUVertexBufferDescription",
        },
        Field {
            name: "num_vertex_buffers",
            doc: Some("The number of vertex buffer descriptions in the above array.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "vertex_attributes",
            doc: Some("A pointer to an array of vertex attribute descriptions.\n"),
            available_since: None,
            ty: "*const SDL_GPUVertexAttribute",
        },
        Field {
            name: "num_vertex_attributes",
            doc: Some("The number of vertex attribute descriptions in the above array.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUStencilOpState: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUStencilOpState",
    doc: Some(
        "A structure specifying the stencil operation state of a graphics pipeline.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUDepthStencilState`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "fail_op",
            doc: Some("The action performed on samples that fail the stencil test.\n"),
            available_since: None,
            ty: "SDL_GPUStencilOp",
        },
        Field {
            name: "pass_op",
            doc: Some("The action performed on samples that pass the depth and stencil tests.\n"),
            available_since: None,
            ty: "SDL_GPUStencilOp",
        },
        Field {
            name: "depth_fail_op",
            doc: Some(
                "The action performed on samples that pass the stencil test and fail the depth test.\n",
            ),
            available_since: None,
            ty: "SDL_GPUStencilOp",
        },
        Field {
            name: "compare_op",
            doc: Some("The comparison operator used in the stencil test.\n"),
            available_since: None,
            ty: "SDL_GPUCompareOp",
        },
    ],
};
pub const METADATA_SDL_GPUColorTargetBlendState: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUColorTargetBlendState",
    doc: Some(
        "A structure specifying the blend state of a color target.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUColorTargetDescription`]\n- [`SDL_GPUBlendFactor`]\n- [`SDL_GPUBlendOp`]\n- [`SDL_GPUColorComponentFlags`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "src_color_blendfactor",
            doc: Some("The value to be multiplied by the source RGB value.\n"),
            available_since: None,
            ty: "SDL_GPUBlendFactor",
        },
        Field {
            name: "dst_color_blendfactor",
            doc: Some("The value to be multiplied by the destination RGB value.\n"),
            available_since: None,
            ty: "SDL_GPUBlendFactor",
        },
        Field {
            name: "color_blend_op",
            doc: Some("The blend operation for the RGB components.\n"),
            available_since: None,
            ty: "SDL_GPUBlendOp",
        },
        Field {
            name: "src_alpha_blendfactor",
            doc: Some("The value to be multiplied by the source alpha.\n"),
            available_since: None,
            ty: "SDL_GPUBlendFactor",
        },
        Field {
            name: "dst_alpha_blendfactor",
            doc: Some("The value to be multiplied by the destination alpha.\n"),
            available_since: None,
            ty: "SDL_GPUBlendFactor",
        },
        Field {
            name: "alpha_blend_op",
            doc: Some("The blend operation for the alpha component.\n"),
            available_since: None,
            ty: "SDL_GPUBlendOp",
        },
        Field {
            name: "color_write_mask",
            doc: Some(
                "A bitmask specifying which of the RGBA components are enabled for writing. Writes to all channels if enable_color_write_mask is false.\n",
            ),
            available_since: None,
            ty: "SDL_GPUColorComponentFlags",
        },
        Field {
            name: "enable_blend",
            doc: Some("Whether blending is enabled for the color target.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "enable_color_write_mask",
            doc: Some("Whether the color write mask is enabled.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUShaderCreateInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUShaderCreateInfo",
    doc: Some(
        "A structure specifying code and metadata for creating a shader object.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUShader`]\n- [`SDL_GPUShaderFormat`]\n- [`SDL_GPUShaderStage`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "code_size",
            doc: Some("The size in bytes of the code pointed to.\n"),
            available_since: None,
            ty: "::core::primitive::usize",
        },
        Field {
            name: "code",
            doc: Some("A pointer to shader code.\n"),
            available_since: None,
            ty: "*const Uint8",
        },
        Field {
            name: "entrypoint",
            doc: Some(
                "A pointer to a null-terminated UTF-8 string specifying the entry point function name for the shader.\n",
            ),
            available_since: None,
            ty: "*const ::core::ffi::c_char",
        },
        Field {
            name: "format",
            doc: Some("The format of the shader code.\n"),
            available_since: None,
            ty: "SDL_GPUShaderFormat",
        },
        Field {
            name: "stage",
            doc: Some("The stage the shader program corresponds to.\n"),
            available_since: None,
            ty: "SDL_GPUShaderStage",
        },
        Field {
            name: "num_samplers",
            doc: Some("The number of samplers defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_storage_textures",
            doc: Some("The number of storage textures defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_storage_buffers",
            doc: Some("The number of storage buffers defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_uniform_buffers",
            doc: Some("The number of uniform buffers defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "props",
            doc: Some("A properties ID for extensions. Should be 0 if no extensions are needed.\n"),
            available_since: None,
            ty: "SDL_PropertiesID",
        },
    ],
};
pub const METADATA_SDL_GPUTextureCreateInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUTextureCreateInfo",
    doc: Some(
        "A structure specifying the parameters of a texture.\n\nUsage flags can be bitwise OR'd together for combinations of usages. Note\nthat certain usage combinations are invalid, for example SAMPLER and\nGRAPHICS_STORAGE.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUTexture`]\n- [`SDL_GPUTextureType`]\n- [`SDL_GPUTextureFormat`]\n- [`SDL_GPUTextureUsageFlags`]\n- [`SDL_GPUSampleCount`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "r#type",
            doc: Some("The base dimensionality of the texture.\n"),
            available_since: None,
            ty: "SDL_GPUTextureType",
        },
        Field {
            name: "format",
            doc: Some("The pixel format of the texture.\n"),
            available_since: None,
            ty: "SDL_GPUTextureFormat",
        },
        Field {
            name: "usage",
            doc: Some("How the texture is intended to be used by the client.\n"),
            available_since: None,
            ty: "SDL_GPUTextureUsageFlags",
        },
        Field {
            name: "width",
            doc: Some("The width of the texture.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "height",
            doc: Some("The height of the texture.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "layer_count_or_depth",
            doc: Some(
                "The layer count or depth of the texture. This value is treated as a layer count on 2D array textures, and as a depth value on 3D textures.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_levels",
            doc: Some("The number of mip levels in the texture.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "sample_count",
            doc: Some(
                "The number of samples per texel. Only applies if the texture is used as a render target.\n",
            ),
            available_since: None,
            ty: "SDL_GPUSampleCount",
        },
        Field {
            name: "props",
            doc: Some("A properties ID for extensions. Should be 0 if no extensions are needed.\n"),
            available_since: None,
            ty: "SDL_PropertiesID",
        },
    ],
};
pub const METADATA_SDL_GPUBufferCreateInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUBufferCreateInfo",
    doc: Some(
        "A structure specifying the parameters of a buffer.\n\nUsage flags can be bitwise OR'd together for combinations of usages. Note\nthat certain combinations are invalid, for example VERTEX and INDEX.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUBuffer`]\n- [`SDL_GPUBufferUsageFlags`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "usage",
            doc: Some("How the buffer is intended to be used by the client.\n"),
            available_since: None,
            ty: "SDL_GPUBufferUsageFlags",
        },
        Field {
            name: "size",
            doc: Some("The size in bytes of the buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "props",
            doc: Some("A properties ID for extensions. Should be 0 if no extensions are needed.\n"),
            available_since: None,
            ty: "SDL_PropertiesID",
        },
    ],
};
pub const METADATA_SDL_GPUTransferBufferCreateInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUTransferBufferCreateInfo",
    doc: Some(
        "A structure specifying the parameters of a transfer buffer.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUTransferBuffer`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "usage",
            doc: Some("How the transfer buffer is intended to be used by the client.\n"),
            available_since: None,
            ty: "SDL_GPUTransferBufferUsage",
        },
        Field {
            name: "size",
            doc: Some("The size in bytes of the transfer buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "props",
            doc: Some("A properties ID for extensions. Should be 0 if no extensions are needed.\n"),
            available_since: None,
            ty: "SDL_PropertiesID",
        },
    ],
};
pub const METADATA_SDL_GPURasterizerState: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPURasterizerState",
    doc: Some(
        "A structure specifying the parameters of the graphics pipeline rasterizer\nstate.\n\nNote that [`SDL_GPU_FILLMODE_LINE`] is not supported on many Android devices.\nFor those devices, the fill mode will automatically fall back to FILL.\n\nAlso note that the D3D12 driver will enable depth clamping even if\nenable_depth_clip is true. If you need this clamp+clip behavior, consider\nenabling depth clip and then manually clamping depth in your fragment\nshaders on Metal and Vulkan.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUGraphicsPipelineCreateInfo`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "fill_mode",
            doc: Some("Whether polygons will be filled in or drawn as lines.\n"),
            available_since: None,
            ty: "SDL_GPUFillMode",
        },
        Field {
            name: "cull_mode",
            doc: Some("The facing direction in which triangles will be culled.\n"),
            available_since: None,
            ty: "SDL_GPUCullMode",
        },
        Field {
            name: "front_face",
            doc: Some(
                "The vertex winding that will cause a triangle to be determined as front-facing.\n",
            ),
            available_since: None,
            ty: "SDL_GPUFrontFace",
        },
        Field {
            name: "depth_bias_constant_factor",
            doc: Some("A scalar factor controlling the depth value added to each fragment.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "depth_bias_clamp",
            doc: Some("The maximum depth bias of a fragment.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "depth_bias_slope_factor",
            doc: Some("A scalar factor applied to a fragment's slope in depth calculations.\n"),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "enable_depth_bias",
            doc: Some("true to bias fragment depth values.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "enable_depth_clip",
            doc: Some("true to enable depth clip, false to enable depth clamp.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUMultisampleState: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUMultisampleState",
    doc: Some(
        "A structure specifying the parameters of the graphics pipeline multisample\nstate.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUGraphicsPipelineCreateInfo`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "sample_count",
            doc: Some("The number of samples to be used in rasterization.\n"),
            available_since: None,
            ty: "SDL_GPUSampleCount",
        },
        Field {
            name: "sample_mask",
            doc: Some("Reserved for future use. Must be set to 0.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "enable_mask",
            doc: Some("Reserved for future use. Must be set to false.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "enable_alpha_to_coverage",
            doc: Some("true enables the alpha-to-coverage feature.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding3",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUDepthStencilState: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUDepthStencilState",
    doc: Some(
        "A structure specifying the parameters of the graphics pipeline depth\nstencil state.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUGraphicsPipelineCreateInfo`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "compare_op",
            doc: Some("The comparison operator used for depth testing.\n"),
            available_since: None,
            ty: "SDL_GPUCompareOp",
        },
        Field {
            name: "back_stencil_state",
            doc: Some("The stencil op state for back-facing triangles.\n"),
            available_since: None,
            ty: "SDL_GPUStencilOpState",
        },
        Field {
            name: "front_stencil_state",
            doc: Some("The stencil op state for front-facing triangles.\n"),
            available_since: None,
            ty: "SDL_GPUStencilOpState",
        },
        Field {
            name: "compare_mask",
            doc: Some(
                "Selects the bits of the stencil values participating in the stencil test.\n",
            ),
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "write_mask",
            doc: Some("Selects the bits of the stencil values updated by the stencil test.\n"),
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "enable_depth_test",
            doc: Some("true enables the depth test.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "enable_depth_write",
            doc: Some(
                "true enables depth writes. Depth writes are always disabled when enable_depth_test is false.\n",
            ),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "enable_stencil_test",
            doc: Some("true enables the stencil test.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding3",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUColorTargetDescription: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUColorTargetDescription",
    doc: Some(
        "A structure specifying the parameters of color targets used in a graphics\npipeline.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUGraphicsPipelineTargetInfo`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "format",
            doc: Some("The pixel format of the texture to be used as a color target.\n"),
            available_since: None,
            ty: "SDL_GPUTextureFormat",
        },
        Field {
            name: "blend_state",
            doc: Some("The blend state to be used for the color target.\n"),
            available_since: None,
            ty: "SDL_GPUColorTargetBlendState",
        },
    ],
};
pub const METADATA_SDL_GPUGraphicsPipelineTargetInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUGraphicsPipelineTargetInfo",
    doc: Some(
        "A structure specifying the descriptions of render targets used in a\ngraphics pipeline.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_GPUGraphicsPipelineCreateInfo`]\n- [`SDL_GPUColorTargetDescription`]\n- [`SDL_GPUTextureFormat`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "color_target_descriptions",
            doc: Some("A pointer to an array of color target descriptions.\n"),
            available_since: None,
            ty: "*const SDL_GPUColorTargetDescription",
        },
        Field {
            name: "num_color_targets",
            doc: Some("The number of color target descriptions in the above array.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "depth_stencil_format",
            doc: Some(
                "The pixel format of the depth-stencil target. Ignored if has_depth_stencil_target is false.\n",
            ),
            available_since: None,
            ty: "SDL_GPUTextureFormat",
        },
        Field {
            name: "has_depth_stencil_target",
            doc: Some("true specifies that the pipeline uses a depth-stencil target.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding3",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUGraphicsPipelineCreateInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUGraphicsPipelineCreateInfo",
    doc: Some(
        "A structure specifying the parameters of a graphics pipeline state.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUGraphicsPipeline`]\n- [`SDL_GPUShader`]\n- [`SDL_GPUVertexInputState`]\n- [`SDL_GPUPrimitiveType`]\n- [`SDL_GPURasterizerState`]\n- [`SDL_GPUMultisampleState`]\n- [`SDL_GPUDepthStencilState`]\n- [`SDL_GPUGraphicsPipelineTargetInfo`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "vertex_shader",
            doc: Some("The vertex shader used by the graphics pipeline.\n"),
            available_since: None,
            ty: "*mut SDL_GPUShader",
        },
        Field {
            name: "fragment_shader",
            doc: Some("The fragment shader used by the graphics pipeline.\n"),
            available_since: None,
            ty: "*mut SDL_GPUShader",
        },
        Field {
            name: "vertex_input_state",
            doc: Some("The vertex layout of the graphics pipeline.\n"),
            available_since: None,
            ty: "SDL_GPUVertexInputState",
        },
        Field {
            name: "primitive_type",
            doc: Some("The primitive topology of the graphics pipeline.\n"),
            available_since: None,
            ty: "SDL_GPUPrimitiveType",
        },
        Field {
            name: "rasterizer_state",
            doc: Some("The rasterizer state of the graphics pipeline.\n"),
            available_since: None,
            ty: "SDL_GPURasterizerState",
        },
        Field {
            name: "multisample_state",
            doc: Some("The multisample state of the graphics pipeline.\n"),
            available_since: None,
            ty: "SDL_GPUMultisampleState",
        },
        Field {
            name: "depth_stencil_state",
            doc: Some("The depth-stencil state of the graphics pipeline.\n"),
            available_since: None,
            ty: "SDL_GPUDepthStencilState",
        },
        Field {
            name: "target_info",
            doc: Some("Formats and blend modes for the render targets of the graphics pipeline.\n"),
            available_since: None,
            ty: "SDL_GPUGraphicsPipelineTargetInfo",
        },
        Field {
            name: "props",
            doc: Some("A properties ID for extensions. Should be 0 if no extensions are needed.\n"),
            available_since: None,
            ty: "SDL_PropertiesID",
        },
    ],
};
pub const METADATA_SDL_GPUComputePipelineCreateInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUComputePipelineCreateInfo",
    doc: Some(
        "A structure specifying the parameters of a compute pipeline state.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_CreateGPUComputePipeline`]\n- [`SDL_GPUShaderFormat`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "code_size",
            doc: Some("The size in bytes of the compute shader code pointed to.\n"),
            available_since: None,
            ty: "::core::primitive::usize",
        },
        Field {
            name: "code",
            doc: Some("A pointer to compute shader code.\n"),
            available_since: None,
            ty: "*const Uint8",
        },
        Field {
            name: "entrypoint",
            doc: Some(
                "A pointer to a null-terminated UTF-8 string specifying the entry point function name for the shader.\n",
            ),
            available_since: None,
            ty: "*const ::core::ffi::c_char",
        },
        Field {
            name: "format",
            doc: Some("The format of the compute shader code.\n"),
            available_since: None,
            ty: "SDL_GPUShaderFormat",
        },
        Field {
            name: "num_samplers",
            doc: Some("The number of samplers defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_readonly_storage_textures",
            doc: Some("The number of readonly storage textures defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_readonly_storage_buffers",
            doc: Some("The number of readonly storage buffers defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_readwrite_storage_textures",
            doc: Some("The number of read-write storage textures defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_readwrite_storage_buffers",
            doc: Some("The number of read-write storage buffers defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "num_uniform_buffers",
            doc: Some("The number of uniform buffers defined in the shader.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "threadcount_x",
            doc: Some(
                "The number of threads in the X dimension. This should match the value in the shader.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "threadcount_y",
            doc: Some(
                "The number of threads in the Y dimension. This should match the value in the shader.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "threadcount_z",
            doc: Some(
                "The number of threads in the Z dimension. This should match the value in the shader.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "props",
            doc: Some("A properties ID for extensions. Should be 0 if no extensions are needed.\n"),
            available_since: None,
            ty: "SDL_PropertiesID",
        },
    ],
};
pub const METADATA_SDL_GPUColorTargetInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUColorTargetInfo",
    doc: Some(
        "A structure specifying the parameters of a color target used by a render\npass.\n\nThe load_op field determines what is done with the texture at the beginning\nof the render pass.\n\n- LOAD: Loads the data currently in the texture. Not recommended for\nmultisample textures as it requires significant memory bandwidth.\n- CLEAR: Clears the texture to a single color.\n- DONT_CARE: The driver will do whatever it wants with the texture memory.\nThis is a good option if you know that every single pixel will be touched\nin the render pass.\n\nThe store_op field determines what is done with the color results of the\nrender pass.\n\n- STORE: Stores the results of the render pass in the texture. Not\nrecommended for multisample textures as it requires significant memory\nbandwidth.\n- DONT_CARE: The driver will do whatever it wants with the texture memory.\nThis is often a good option for depth/stencil textures.\n- RESOLVE: Resolves a multisample texture into resolve_texture, which must\nhave a sample count of 1. Then the driver may discard the multisample\ntexture memory. This is the most performant method of resolving a\nmultisample target.\n- RESOLVE_AND_STORE: Resolves a multisample texture into the\nresolve_texture, which must have a sample count of 1. Then the driver\nstores the multisample texture's contents. Not recommended as it requires\nsignificant memory bandwidth.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BeginGPURenderPass`]\n- [`SDL_FColor`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "texture",
            doc: Some("The texture that will be used as a color target by a render pass.\n"),
            available_since: None,
            ty: "*mut SDL_GPUTexture",
        },
        Field {
            name: "mip_level",
            doc: Some("The mip level to use as a color target.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "layer_or_depth_plane",
            doc: Some(
                "The layer index or depth plane to use as a color target. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "clear_color",
            doc: Some(
                "The color to clear the color target to at the start of the render pass. Ignored if [`SDL_GPU_LOADOP_CLEAR`] is not used.\n",
            ),
            available_since: None,
            ty: "SDL_FColor",
        },
        Field {
            name: "load_op",
            doc: Some(
                "What is done with the contents of the color target at the beginning of the render pass.\n",
            ),
            available_since: None,
            ty: "SDL_GPULoadOp",
        },
        Field {
            name: "store_op",
            doc: Some("What is done with the results of the render pass.\n"),
            available_since: None,
            ty: "SDL_GPUStoreOp",
        },
        Field {
            name: "resolve_texture",
            doc: Some(
                "The texture that will receive the results of a multisample resolve operation. Ignored if a RESOLVE* store_op is not used.\n",
            ),
            available_since: None,
            ty: "*mut SDL_GPUTexture",
        },
        Field {
            name: "resolve_mip_level",
            doc: Some(
                "The mip level of the resolve texture to use for the resolve operation. Ignored if a RESOLVE* store_op is not used.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "resolve_layer",
            doc: Some(
                "The layer index of the resolve texture to use for the resolve operation. Ignored if a RESOLVE* store_op is not used.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "cycle",
            doc: Some("true cycles the texture if the texture is bound and load_op is not LOAD\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "cycle_resolve_texture",
            doc: Some(
                "true cycles the resolve texture if the resolve texture is bound. Ignored if a RESOLVE* store_op is not used.\n",
            ),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUDepthStencilTargetInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUDepthStencilTargetInfo",
    doc: Some(
        "A structure specifying the parameters of a depth-stencil target used by a\nrender pass.\n\nThe load_op field determines what is done with the depth contents of the\ntexture at the beginning of the render pass.\n\n- LOAD: Loads the depth values currently in the texture.\n- CLEAR: Clears the texture to a single depth.\n- DONT_CARE: The driver will do whatever it wants with the memory. This is\na good option if you know that every single pixel will be touched in the\nrender pass.\n\nThe store_op field determines what is done with the depth results of the\nrender pass.\n\n- STORE: Stores the depth results in the texture.\n- DONT_CARE: The driver will do whatever it wants with the depth results.\nThis is often a good option for depth/stencil textures that don't need to\nbe reused again.\n\nThe stencil_load_op field determines what is done with the stencil contents\nof the texture at the beginning of the render pass.\n\n- LOAD: Loads the stencil values currently in the texture.\n- CLEAR: Clears the stencil values to a single value.\n- DONT_CARE: The driver will do whatever it wants with the memory. This is\na good option if you know that every single pixel will be touched in the\nrender pass.\n\nThe stencil_store_op field determines what is done with the stencil results\nof the render pass.\n\n- STORE: Stores the stencil results in the texture.\n- DONT_CARE: The driver will do whatever it wants with the stencil results.\nThis is often a good option for depth/stencil textures that don't need to\nbe reused again.\n\nNote that depth/stencil targets do not support multisample resolves.\n\nDue to ABI limitations, depth textures with more than 255 layers are not\nsupported.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BeginGPURenderPass`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "texture",
            doc: Some(
                "The texture that will be used as the depth stencil target by the render pass.\n",
            ),
            available_since: None,
            ty: "*mut SDL_GPUTexture",
        },
        Field {
            name: "clear_depth",
            doc: Some(
                "The value to clear the depth component to at the beginning of the render pass. Ignored if [`SDL_GPU_LOADOP_CLEAR`] is not used.\n",
            ),
            available_since: None,
            ty: "::core::ffi::c_float",
        },
        Field {
            name: "load_op",
            doc: Some(
                "What is done with the depth contents at the beginning of the render pass.\n",
            ),
            available_since: None,
            ty: "SDL_GPULoadOp",
        },
        Field {
            name: "store_op",
            doc: Some("What is done with the depth results of the render pass.\n"),
            available_since: None,
            ty: "SDL_GPUStoreOp",
        },
        Field {
            name: "stencil_load_op",
            doc: Some(
                "What is done with the stencil contents at the beginning of the render pass.\n",
            ),
            available_since: None,
            ty: "SDL_GPULoadOp",
        },
        Field {
            name: "stencil_store_op",
            doc: Some("What is done with the stencil results of the render pass.\n"),
            available_since: None,
            ty: "SDL_GPUStoreOp",
        },
        Field {
            name: "cycle",
            doc: Some(
                "true cycles the texture if the texture is bound and any load ops are not LOAD\n",
            ),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "clear_stencil",
            doc: Some(
                "The value to clear the stencil component to at the beginning of the render pass. Ignored if [`SDL_GPU_LOADOP_CLEAR`] is not used.\n",
            ),
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "mip_level",
            doc: Some("The mip level to use as the depth stencil target.\n"),
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "layer",
            doc: Some("The layer index to use as the depth stencil target.\n"),
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUBlitInfo: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUBlitInfo",
    doc: Some(
        "A structure containing parameters for a blit command.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BlitGPUTexture`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "source",
            doc: Some("The source region for the blit.\n"),
            available_since: None,
            ty: "SDL_GPUBlitRegion",
        },
        Field {
            name: "destination",
            doc: Some("The destination region for the blit.\n"),
            available_since: None,
            ty: "SDL_GPUBlitRegion",
        },
        Field {
            name: "load_op",
            doc: Some("What is done with the contents of the destination before the blit.\n"),
            available_since: None,
            ty: "SDL_GPULoadOp",
        },
        Field {
            name: "clear_color",
            doc: Some(
                "The color to clear the destination region to before the blit. Ignored if load_op is not [`SDL_GPU_LOADOP_CLEAR`].\n",
            ),
            available_since: None,
            ty: "SDL_FColor",
        },
        Field {
            name: "flip_mode",
            doc: Some("The flip mode for the source region.\n"),
            available_since: None,
            ty: "SDL_FlipMode",
        },
        Field {
            name: "filter",
            doc: Some("The filter mode used when blitting.\n"),
            available_since: None,
            ty: "SDL_GPUFilter",
        },
        Field {
            name: "cycle",
            doc: Some("true cycles the destination texture if it is already bound.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding3",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUBufferBinding: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUBufferBinding",
    doc: Some(
        "A structure specifying parameters in a buffer binding call.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BindGPUVertexBuffers`]\n- [`SDL_BindGPUIndexBuffer`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "buffer",
            doc: Some(
                "The buffer to bind. Must have been created with [`SDL_GPU_BUFFERUSAGE_VERTEX`] for [`SDL_BindGPUVertexBuffers`], or [`SDL_GPU_BUFFERUSAGE_INDEX`] for [`SDL_BindGPUIndexBuffer`].\n",
            ),
            available_since: None,
            ty: "*mut SDL_GPUBuffer",
        },
        Field {
            name: "offset",
            doc: Some("The starting byte of the data to bind in the buffer.\n"),
            available_since: None,
            ty: "Uint32",
        },
    ],
};
pub const METADATA_SDL_GPUTextureSamplerBinding: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUTextureSamplerBinding",
    doc: Some(
        "A structure specifying parameters in a sampler binding call.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BindGPUVertexSamplers`]\n- [`SDL_BindGPUFragmentSamplers`]\n- [`SDL_GPUTexture`]\n- [`SDL_GPUSampler`]\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "texture",
            doc: Some(
                "The texture to bind. Must have been created with [`SDL_GPU_TEXTUREUSAGE_SAMPLER`].\n",
            ),
            available_since: None,
            ty: "*mut SDL_GPUTexture",
        },
        Field {
            name: "sampler",
            doc: Some("The sampler to bind.\n"),
            available_since: None,
            ty: "*mut SDL_GPUSampler",
        },
    ],
};
pub const METADATA_SDL_GPUStorageBufferReadWriteBinding: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUStorageBufferReadWriteBinding",
    doc: Some(
        "A structure specifying parameters related to binding buffers in a compute\npass.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BeginGPUComputePass`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "buffer",
            doc: Some(
                "The buffer to bind. Must have been created with [`SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE`].\n",
            ),
            available_since: None,
            ty: "*mut SDL_GPUBuffer",
        },
        Field {
            name: "cycle",
            doc: Some("true cycles the buffer if it is already bound.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding3",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUStorageTextureReadWriteBinding: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUStorageTextureReadWriteBinding",
    doc: Some(
        "A structure specifying parameters related to binding textures in a compute\npass.\n\n## Availability\nThis struct is available since SDL 3.2.0.\n\n## See also\n- [`SDL_BeginGPUComputePass`]\n\n## Notes for `sdl3-sys`\nThis struct has padding fields which shouldn't be accessed directly; use struct update syntax with e.g. `..Default::default()` for manual construction.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 2, 0)),
    fields: &[
        Field {
            name: "texture",
            doc: Some(
                "The texture to bind. Must have been created with [`SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE`] or [`SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE`].\n",
            ),
            available_since: None,
            ty: "*mut SDL_GPUTexture",
        },
        Field {
            name: "mip_level",
            doc: Some("The mip level index to bind.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "layer",
            doc: Some("The layer index to bind.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "cycle",
            doc: Some("true cycles the texture if it is already bound.\n"),
            available_since: None,
            ty: "::core::primitive::bool",
        },
        Field {
            name: "padding1",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding2",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
        Field {
            name: "padding3",
            doc: None,
            available_since: None,
            ty: "Uint8",
        },
    ],
};
pub const METADATA_SDL_GPUVulkanOptions: Struct = Struct {
    module: "gpu",
    kind: StructKind::Struct,
    name: "SDL_GPUVulkanOptions",
    doc: Some(
        "A structure specifying additional options when using Vulkan.\n\nWhen no such structure is provided, SDL will use Vulkan API version 1.0 and\na minimal set of features. The requested API version influences how the\nfeature_list is processed by SDL. When requesting API version 1.0, the\nfeature_list is ignored. Only the vulkan_10_physical_device_features and\nthe extension lists are used. When requesting API version 1.1, the\nfeature_list is scanned for feature structures introduced in Vulkan 1.1.\nWhen requesting Vulkan 1.2 or higher, the feature_list is additionally\nscanned for compound feature structs such as\nVkPhysicalDeviceVulkan11Features. The device and instance extension lists,\nas well as vulkan_10_physical_device_features, are always processed.\n\n## Availability\nThis struct is available since SDL 3.4.0.\n",
    ),
    available_since: Some(SDL_VERSIONNUM(3, 4, 0)),
    fields: &[
        Field {
            name: "vulkan_api_version",
            doc: Some(
                "The Vulkan API version to request for the instance. Use Vulkan's VK_MAKE_VERSION or VK_MAKE_API_VERSION.\n",
            ),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "feature_list",
            doc: Some(
                "Pointer to the first element of a chain of Vulkan feature structs. (Requires API version 1.1 or higher.)\n",
            ),
            available_since: None,
            ty: "*mut ::core::ffi::c_void",
        },
        Field {
            name: "vulkan_10_physical_device_features",
            doc: Some(
                "Pointer to a VkPhysicalDeviceFeatures struct to enable additional Vulkan 1.0 features.\n",
            ),
            available_since: None,
            ty: "*mut ::core::ffi::c_void",
        },
        Field {
            name: "device_extension_count",
            doc: Some("Number of additional device extensions to require.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "device_extension_names",
            doc: Some("Pointer to a list of additional device extensions to require.\n"),
            available_since: None,
            ty: "*mut *const ::core::ffi::c_char",
        },
        Field {
            name: "instance_extension_count",
            doc: Some("Number of additional instance extensions to require.\n"),
            available_since: None,
            ty: "Uint32",
        },
        Field {
            name: "instance_extension_names",
            doc: Some("Pointer to a list of additional instance extensions to require.\n"),
            available_since: None,
            ty: "*mut *const ::core::ffi::c_char",
        },
    ],
};
